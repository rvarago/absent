#ifndef RVARAGO_ABSENT_BIND_H
#define RVARAGO_ABSENT_BIND_H

#include "absent/syntax/member.h"
#include "absent/syntax/nullable.h"

#include <functional>
#include <utility>

namespace rvarago::absent {

    /***
     * Given a nullable type N<A> (i.e. optional like object), and an unary function f: A -> N<B>:
     * - When empty: it should return a new empty nullable N<B>.
     * - When *not* empty: it should return a value generated by applying the unary mapping function to the input
     * nullable's which is already wrapped a nullable N<B>.
     *
     * @param input any optional like object that can be checked against empty and provide access to its wrapped value.
     * @param fn an unary function A -> N<B>.
     * @return a new nullable generated by fn, possibly empty if input is also empty.
     */
    template <template <typename, typename...> typename Nullable, typename Mapper, typename A, typename... Rest>
    constexpr auto bind(Nullable<A, Rest...> input, Mapper fn) -> decltype(fn(std::declval<A>())) {
        return syntax::nullable<Nullable, Mapper, A, Rest...>::bind(std::move(input), fn);
    }

    /***
     * The same as bind but for a member function that has to be const and parameterless.
     */
    template <template <typename, typename...> typename Nullable, typename A, typename B, typename... Rest>
    constexpr auto bind(Nullable<A, Rest...> input, syntax::member::Mapper<const A, Nullable<B, Rest...>> fn) -> Nullable<B, Rest...> {
        return bind(input, [&fn](auto value){ return std::invoke(fn, std::move(value)); });
    }

    /***
     * Infix version of bind.
     */
    template <template <typename, typename...> typename Nullable, typename Mapper, typename A, typename... Rest>
    constexpr auto operator>>(Nullable<A, Rest...> input, Mapper fn) -> decltype(bind(input, fn)) {
        return bind(std::move(input), fn);
    }

    /***
     * Infix version of bind for a member function.
     */
    template <template <typename, typename...> typename Nullable, typename A, typename B, typename... Rest>
    constexpr auto operator>>(Nullable<A, Rest...> input, syntax::member::Mapper<const A, Nullable<B, Rest...>> fn) -> Nullable<B, Rest...> {
        return bind(std::move(input), fn);
    }

}

#endif //RVARAGO_ABSENT_BIND_H
